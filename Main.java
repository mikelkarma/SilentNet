// > Assinatura gerada: K1h7dw4IcdSCXYKZdrO8HXTc7JECsjql7DdGpbdn0r6sVoGaiC8CfkMCVqnQ9F6ceB2ptP+tNupFDm7liRy5Lqy+pD50xAOw6fq/OAOfMhkvK6swaKYwcXZ1c+zpWRVnifRLrvpPrsDHsxkCWbQsoCLh14VsVA10xhh2jDXIhYEtfEpnQxYbF4jec42GIhyKVm3RHw2XC2vVWcTyvxgsyvt2UttFfDaTXbXWmantUlkwaOG8VnT5kDoOFQ5ngWCg0Ja5OjMTt0pKpmMwhuTVgK0hL69aBWOJ1R8x++eouv2B6ZpYX+7mSJ9f++z0vdHYs1/0Twkh0GaHsBcT5Tu21LRbY8BcyrzSj8psJjktU8B/AbEq1aZdJGtai0N9srUiZVobx5q49AJIynJLk+1a9tz1i3zCZQCR1L8a9EHosjEQ2xuLm67BmngBQXs+May/1Xtgl1bZZwR7S49uDPdSXIjTlw8bSV0+UsREW1logcN3B5d4vYoHX+Y7GkoxFdwy
// > Chave AES gerada: dqUvEG6nXO+FGyu6Xr1Q/VcKZd+GVqQt6kehB0X+ESE=
// > Dados criptografados com AES: 3HVXKyFf1nz3eBV2vBHYBmrUn+7wTVI463/9WFhYpSk=
// > Chave AES criptografada com RSA: sYrJEUxJIX4J4kEEYifRSwqsvrV3KzoR8ilePROApYW8C9g2zLWuH80n4giEJEz6xAtqk25kIyYWbQXGkHupNSvCCHlmrftgEpXOVEu3mVjbV21D7dFSj2tSBoDxUV5tFW2dX6ihtacJOAOsZpEv3z1Kxhm4kpIJi7LfyTXkku66hN674Ng51B2xbLK8Siny8JneKULHRehDdpETCBUBjijuU9J65BpPHHVOMliOuOIRiziU8gr1gs1/YuAhXAz22s2K32yY6DDLY7uWSJKJ7/TLCzSsfxGAS90QDZPBDpi0nrSRKJlbdyFLeXc+tGb8lZ44KurhnBRkBnofc5S5kw==
// > Assinatura criptografada com AES: mzDe7wRa1OPEN4pNfPhUXpa/yP8PQ2HJvpnHfSe4R3UVo4ELLEyhkA+5ADvCMk708mZN+AOrdHN2QGFD7S6yaj0tZlpsk5dPvRLjNeRAyigR1fnmWbF32QHQTd7U5IIO4s3cL/A0cxHk1HjbqlR2ridrQcFxRdX3RO8vP1PiCpgnYxvk4ozhkfCiA6k3jroL/20vFxK93eH+KPkxCcd9Hn2GmuKqxTPW+DhbQppeIDO/RB0EKvDvri6ZJM0DGdvtUy+H6PCY1l6HLKllgaRYdMwJfitGy/nKnlfts8flcv6K2kA9ZFxydpVCuyi9xVjyS2Zk8Jt1/mMBG3XZ+2wI/G7s7MNzx3/u+ishPWHUJRZEKaqPi0kkLIY3YXLu2OSV3ijg0aqeLDGVNGw3GV2trMm3RLOHp+wqDqQpJ3WBrJNAYqN33juAVvNe+yjIiUi6zMSwomuShTW4cmIX1RXodboQ1Wz5K1zX92vs3brcmc0Jwx9Ei83FEiiPZWjCgKoNdLk5W/ZP6h7U8f78DOUfsGZdB7EqdhLsFQmnij+3gE7jK2PXfytl6SGqIK2WrSPjh0KEA0Tityx3/2iQ3Syv1TL6TKTP2SaRVFybA4n51QH4kVSTgkzO/KJjlZmIXT4zMfOP8MeaIoYWXrh2usLIZrOQwNOY5g3/hcsYGjPIeffCO7WuGhuT04Onfj+zr1Li
// > Chave pública do cliente criptografada: CXXzrBaCHGZR8My6DkPjBo49AHa+dNh1N5Y4e1oT08egPTt4oiYSGaZlLpKiBoXA+dy0PfuduRgOHCJUJiRTJrhB8oywdvYbeyu8wYDchaWE0frmC1USOVkgnrFVHdYW5GCJp0/5xZ3b/mT01liysGncdJLwNCADkRO7bE42wWCmwsGhzIQvj3R5l22M9ls14rQufwP1MXt6KXQOtoecTJsPEDUY7O4KfPBltVV7SR0rjmyJ/MpmoSvufT3TbJ9oY8x6rAIVt70F8Ug4FOm2qb9SToXqzCa/j3EWIJU0EwdonCMNNxg4G0yqFeDYllF5VLnklITTO6uYe2yWQteCRY2OB1lscX79KLxOL4AwZA69fWBQw4cz6pw+xI4YsdB1mGjDDRJ3GsFPp5YvFz1VQcyDDzpwRHUYuFHQ1BhJ9fNEnpI14SozigsSCFZYAP1SUe01V3AIZNC3zadETltBjy+4o+oSVLKDUist1fS1V2CHo8z58S1bpDyDS7rg3sWYXoHAIXFHBAJt/k0TsNsy5dIzpWVlYn/RAptAMfjXxPYZgqgbMrOvOa0cvlApWxPKSVT3qNihKNwAUyVJEm6mF5wZ+ADw/xEr9ex+FFH7GL4JZePHZCArb0RM672CGjPiTWPLg6N4NQnjY+ZGOKZR4QO4UjrdkryA0Lb/yj9t/y6Wu17TREUqDIYycLlhy+xiqRkdF/wWpzcr6Plc+SoAZoqZKX34PyZv/A1jXfqGLbq42MdjRPEx8g+cwCPFvrV0
// > Formato dos dados: mzDe7wRa1OPEN4pNfPhUXpa/yP8PQ2HJvpnHfSe4R3UVo4ELLEyhkA+5ADvCMk708mZN+AOrdHN2QGFD7S6yaj0tZlpsk5dPvRLjNeRAyigR1fnmWbF32QHQTd7U5IIO4s3cL/A0cxHk1HjbqlR2ridrQcFxRdX3RO8vP1PiCpgnYxvk4ozhkfCiA6k3jroL/20vFxK93eH+KPkxCcd9Hn2GmuKqxTPW+DhbQppeIDO/RB0EKvDvri6ZJM0DGdvtUy+H6PCY1l6HLKllgaRYdMwJfitGy/nKnlfts8flcv6K2kA9ZFxydpVCuyi9xVjyS2Zk8Jt1/mMBG3XZ+2wI/G7s7MNzx3/u+ishPWHUJRZEKaqPi0kkLIY3YXLu2OSV3ijg0aqeLDGVNGw3GV2trMm3RLOHp+wqDqQpJ3WBrJNAYqN33juAVvNe+yjIiUi6zMSwomuShTW4cmIX1RXodboQ1Wz5K1zX92vs3brcmc0Jwx9Ei83FEiiPZWjCgKoNdLk5W/ZP6h7U8f78DOUfsGZdB7EqdhLsFQmnij+3gE7jK2PXfytl6SGqIK2WrSPjh0KEA0Tityx3/2iQ3Syv1TL6TKTP2SaRVFybA4n51QH4kVSTgkzO/KJjlZmIXT4zMfOP8MeaIoYWXrh2usLIZrOQwNOY5g3/hcsYGjPIeffCO7WuGhuT04Onfj+zr1Li,sYrJEUxJIX4J4kEEYifRSwqsvrV3KzoR8ilePROApYW8C9g2zLWuH80n4giEJEz6xAtqk25kIyYWbQXGkHupNSvCCHlmrftgEpXOVEu3mVjbV21D7dFSj2tSBoDxUV5tFW2dX6ihtacJOAOsZpEv3z1Kxhm4kpIJi7LfyTXkku66hN674Ng51B2xbLK8Siny8JneKULHRehDdpETCBUBjijuU9J65BpPHHVOMliOuOIRiziU8gr1gs1/YuAhXAz22s2K32yY6DDLY7uWSJKJ7/TLCzSsfxGAS90QDZPBDpi0nrSRKJlbdyFLeXc+tGb8lZ44KurhnBRkBnofc5S5kw==,3HVXKyFf1nz3eBV2vBHYBmrUn+7wTVI463/9WFhYpSk=,CXXzrBaCHGZR8My6DkPjBo49AHa+dNh1N5Y4e1oT08egPTt4oiYSGaZlLpKiBoXA+dy0PfuduRgOHCJUJiRTJrhB8oywdvYbeyu8wYDchaWE0frmC1USOVkgnrFVHdYW5GCJp0/5xZ3b/mT01liysGncdJLwNCADkRO7bE42wWCmwsGhzIQvj3R5l22M9ls14rQufwP1MXt6KXQOtoecTJsPEDUY7O4KfPBltVV7SR0rjmyJ/MpmoSvufT3TbJ9oY8x6rAIVt70F8Ug4FOm2qb9SToXqzCa/j3EWIJU0EwdonCMNNxg4G0yqFeDYllF5VLnklITTO6uYe2yWQteCRY2OB1lscX79KLxOL4AwZA69fWBQw4cz6pw+xI4YsdB1mGjDDRJ3GsFPp5YvFz1VQcyDDzpwRHUYuFHQ1BhJ9fNEnpI14SozigsSCFZYAP1SUe01V3AIZNC3zadETltBjy+4o+oSVLKDUist1fS1V2CHo8z58S1bpDyDS7rg3sWYXoHAIXFHBAJt/k0TsNsy5dIzpWVlYn/RAptAMfjXxPYZgqgbMrOvOa0cvlApWxPKSVT3qNihKNwAUyVJEm6mF5wZ+ADw/xEr9ex+FFH7GL4JZePHZCArb0RM672CGjPiTWPLg6N4NQnjY+ZGOKZR4QO4UjrdkryA0Lb/yj9t/y6Wu17TREUqDIYycLlhy+xiqRkdF/wWpzcr6Plc+SoAZoqZKX34PyZv/A1jXfqGLbq42MdjRPEx8g+cwCPFvrV0

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;
import java.util.Base64;
import java.security.spec.X509EncodedKeySpec;
import java.security.spec.PKCS8EncodedKeySpec;


public class Main {

    static KeyPair rsaMasterKeyPair;
    static KeyPair rsaClientKeyPair;
    static PublicKey publicKeyMaster;
    static PrivateKey privateKeyMaster;
    static PublicKey publicKeyClient;
    static PrivateKey privateKeyClient;

    static {
        try {
            // Chave RSA master fornecida em Base64 (em um ambiente real, isso seria uma chave real)
            String base64MasterPublicKey = "MIIBojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEArLA9rcHRjIG2vNTJmS3zMBgYEkuJMZCrpRUCstBK48Uwdp+1zNxxj81e/XLayN8dD8qNIusWckgyUGDTM4LNv+XdKCVgQaDV0jOeIfJqYFK6cPGf2UsDfcWUwpNi/UChv8HD9QI+qglxumYJuY/ttaOrxMUEhnIcnBMgcHb3P+dlsx1VrNfz3oh1UwqrYVglgy1w0sNeNVvOLIjuxbDPnq2wh5dnC+GogxXdB4TXQdeXzOB8gp3Cbc4CW9aycIRnyrrV9ywBaosulgUKwDvtHXk8YjhnyNyviwnoRA4TLnraFTET/BuqaR9sJ1FJ85UNGF+ElAp0u4e354NvPId0oaamaQhGL8xL3aAJgOCmto3xi5Tar7OGJ5WTGzxtAmOcqps3skXFYVcM9KFy19oFymTHkvu556sP648zSTr+jXGO+a1A7SXWv2cEpv3RrqOR8+UQkKRl9ldxKGZ8ePQ4m7etzFxuljYJl08k77q41s9a+HFdYa7qn9Rz+o5OrsG7AgMBAAE=";
            // Convertendo as chaves de Base64 para Key objects
            byte[] publicKeyBytes = Base64.getDecoder().decode(base64MasterPublicKey);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");

            publicKeyMaster = keyFactory.generatePublic(new X509EncodedKeySpec(publicKeyBytes));
            
            // Gerando as chaves do cliente
            rsaClientKeyPair = generateRSAKey();
            publicKeyClient = rsaClientKeyPair.getPublic();
            privateKeyClient = rsaClientKeyPair.getPrivate();
            
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Erro ao inicializar as chaves RSA");
        }
    }

    // Gerar chave RSA
    public static KeyPair generateRSAKey() throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(3072);
        return keyPairGenerator.generateKeyPair();
    }

    // Criptografar com RSA
    public static String encryptRSA(SecretKey aesKey, PublicKey rsaPublicKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
        cipher.init(Cipher.ENCRYPT_MODE, rsaPublicKey);
        byte[] encryptedAESKey = cipher.doFinal(aesKey.getEncoded());
        return Base64.getEncoder().encodeToString(encryptedAESKey);
    }

    // Descriptografar com RSA
    public static SecretKey decryptRSA(String encryptedAESKey, PrivateKey rsaPrivateKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
        cipher.init(Cipher.DECRYPT_MODE, rsaPrivateKey);
        byte[] decodedEncryptedAESKey = Base64.getDecoder().decode(encryptedAESKey);
        byte[] decryptedAESKey = cipher.doFinal(decodedEncryptedAESKey);
        return new SecretKeySpec(decryptedAESKey, "AES");
    }

    // Gerar chave AES
    public static SecretKey generateAESKey() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(256);
        return keyGenerator.generateKey();
    }

    // Criptografar com AES
    public static String encryptAES(String data, SecretKey key) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] encryptedData = cipher.doFinal(data.getBytes());
        return Base64.getEncoder().encodeToString(encryptedData);
    }

    // Descriptografar com AES
    public static String decryptAES(String data, SecretKey key) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] decodedData = Base64.getDecoder().decode(data);
        byte[] decryptedData = cipher.doFinal(decodedData);
        return new String(decryptedData);
    }

    // Assinar dados com a chave privada RSA
    public static String signData(byte[] data, PrivateKey privateKey) throws Exception {
        Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initSign(privateKey);
        signature.update(data);
        byte[] signedData = signature.sign();
        return Base64.getEncoder().encodeToString(signedData);
    }

    // Verificar assinatura
    public static boolean verifySignature(byte[] data, String signatureStr, PublicKey publicKey) throws Exception {
        Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initVerify(publicKey);
        signature.update(data);
        byte[] signatureBytes = Base64.getDecoder().decode(signatureStr);
        return signature.verify(signatureBytes);
    }

    // Imprimir mensagens
    public static void print(String text) {
        System.out.println(text);
    }

    // Função principal
    public static void main(String[] args) {
    try {
        // Gerar chave AES e criptografar dados
        SecretKey aesKey = generateAESKey();
        String data = "Informação confidencial";

        // Assinar a mensagem
        String signature = signData(data.getBytes(), privateKeyClient);
        print(" > Assinatura gerada: " + signature);
        print(" > Chave AES gerada: " + Base64.getEncoder().encodeToString(aesKey.getEncoded()));

        // Criptografar os dados com AES
        String encryptedData = encryptAES(data, aesKey);
        print(" > Dados criptografados com AES: " + encryptedData);

        // Criptografar a chave AES com RSA
        String encryptedAESKey = encryptRSA(aesKey, publicKeyMaster);
        print(" > Chave AES criptografada com RSA: " + encryptedAESKey);

        // Criptografar a assinatura com AES
        String encryptedSignature = encryptAES(signature, aesKey);
        print(" > Assinatura criptografada com AES: " + encryptedSignature);

        // Serializar e criptografar chave pública do cliente
        String serializedPublicKeyClient = Base64.getEncoder().encodeToString(publicKeyClient.getEncoded());
        String encryptedPublicKeyClient = encryptAES(serializedPublicKeyClient, aesKey);
        print(" > Chave pública do cliente criptografada: " + encryptedPublicKeyClient);

        // Simulação de envio
        print(" > Formato dos dados: " + encryptedSignature + "," + encryptedAESKey + "," + encryptedData + "," + encryptedPublicKeyClient);

    } catch (Exception e) {
        e.printStackTrace();
    }
}}
